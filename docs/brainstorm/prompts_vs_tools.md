# 提示词 vs 工具：CursorFocus 的灵魂拷问

> "为什么不直接让 AI 生成呢？为什么要费劲巴拉地写这些代码呢？"

这是一个非常深刻的问题，触及了工具开发的本质。本文档记录了将 CursorFocus 的核心功能提炼为两个提示词的过程，以及对工具化 vs 提示词方案的深入思考。

## 核心提示词

### 提示词 1：生成 Focus.md 文件

```markdown
请分析这个项目并生成一个 Focus.md 文件。请按照以下格式和要求：

1. **项目标题和概述**
   - 项目名称（从文件夹名或配置文件中提取）
   - 当前目标（一句话描述项目的主要功能）
   - 项目上下文：
     - 类型（Web应用/CLI工具/库/框架等）
     - 目标用户
     - 主要功能
     - 关键需求（列出3-5个核心特性）
   - 开发指南（3条最重要的开发原则）

2. **项目结构树**
   - 使用树形结构展示所有重要文件和文件夹
   - 每个文件后面标注：行数和简短描述
   - 使用图标：📁 文件夹，📄 文件
   - 忽略：node_modules, venv, .git, __pycache__, build, dist 等
   - 只展示代码文件（.py, .js, .ts, .jsx, .tsx, .java, .cpp 等）

3. **关键文件和方法**
   - 列出包含函数/方法的文件
   - 每个文件下列出主要函数名（排除 __init__, __str__ 等特殊方法）
   - 按文件名字母顺序排序

4. **项目统计**
   - 总文件数和总行数
   - 按文件类型分布（如：.py: 10个文件，1500行）
   - 更新时间

请扫描当前目录下的所有文件，生成完整的 Focus.md 内容。
```

### 提示词 2：生成 .cursorrules 文件

```markdown
请分析这个项目的代码风格、模式和最佳实践，生成一个 .cursorrules 文件。请包含以下内容：

1. **项目信息**
   - 版本、更新时间
   - 项目名称、主要语言、框架、类型
   - 项目描述（2-3句话说明项目的核心功能和技术特点）

2. **AI 行为规则**（基于代码分析生成）
   
   分析项目中的所有代码文件，提取以下模式：
   
   a) **代码风格规则**
      - 命名约定（变量、函数、类、文件）
      - 缩进和格式化偏好
      - 注释风格
      - 导入语句组织方式
   
   b) **错误处理模式**
      - try-catch/except 使用方式
      - 错误日志记录方法
      - 异常类型和自定义异常
   
   c) **性能优化模式**
      - 常用的优化技巧
      - 缓存策略
      - 异步处理方式
   
   d) **架构和组织**
      - 模块组织结构
      - 依赖管理方式
      - 设计模式使用
      - 测试文件组织
   
   e) **项目特定规则**
      - 框架特定的最佳实践
      - 项目独特的约定
      - 配置管理方式

3. **输出格式要求**
   - 使用 Markdown 格式
   - 每个规则类别用二级标题
   - 规则用列表形式，分为"推荐"和"避免"
   - 包含具体的代码示例

请深入分析项目的每个代码文件，识别重复出现的模式，生成符合项目实际情况的规则文件。重点关注：
- 实际使用的编码风格（不是理论最佳实践）
- 项目特有的模式和约定
- 现有代码的技能水平和复杂度
```

## 使用方法

### 方法一：直接使用
1. 在项目根目录打开 Cursor
2. 新建对话，粘贴相应的提示词
3. AI 会自动分析项目并生成文件

### 方法二：创建快捷命令
1. 在 Cursor 的设置中添加自定义命令
2. 将提示词保存为模板
3. 通过快捷键快速调用

### 方法三：结合脚本使用
```bash
# 简单的辅助脚本
echo "生成 Focus.md 中..."
# 将提示词通过 API 发送给 AI
# 保存生成的内容到 Focus.md
```

## 对比分析

### 工具化方案（CursorFocus）

**优势：**
- ✅ 完全自动化，一键生成
- ✅ 支持批量处理多个项目
- ✅ 实时监控文件变化并更新
- ✅ 统一的输出格式和质量
- ✅ 可集成到 CI/CD 流程
- ✅ 支持团队协作和标准化

**劣势：**
- ❌ 需要安装和配置环境
- ❌ 需要 API Key（如 Gemini）
- ❌ 维护成本高（700+ 行代码）
- ❌ 输出模板相对固定
- ❌ 可能过度工程化

### 提示词方案

**优势：**
- ✅ 零安装，即用即走
- ✅ 使用 Cursor 内置 AI，无需额外 API
- ✅ 极其灵活，可随时调整
- ✅ 输出质量可能更高（AI 能看到完整上下文）
- ✅ 维护成本几乎为零
- ✅ 符合 KISS 原则

**劣势：**
- ❌ 需要手动执行
- ❌ 无法自动监控变化
- ❌ 批量处理不便
- ❌ 输出一致性依赖 AI 模型
- ❌ 难以标准化和版本控制

## 深层思考

### 什么时候需要工具化？

1. **规模化需求**
   - 管理 10+ 个项目
   - 团队统一规范
   - 定期批量更新

2. **自动化需求**
   - 集成到 CI/CD
   - 代码提交触发更新
   - 定时任务执行

3. **标准化需求**
   - 企业级应用
   - 合规性要求
   - 质量保证体系

### 什么时候提示词更好？

1. **个人项目**
   - 项目数量少
   - 更新频率低
   - 需要灵活定制

2. **探索阶段**
   - 还在寻找最佳格式
   - 需要快速迭代
   - 不同项目差异大

3. **轻量使用**
   - 偶尔需要生成
   - 不想维护工具
   - 追求简单高效

## 哲学反思

这个"灵魂拷问"实际上反映了软件开发中的一个永恒主题：

> **我们是在解决问题，还是在创造问题？**

### 过度工程化的陷阱

很多时候，程序员倾向于：
- 把简单问题复杂化
- 为了自动化而自动化
- 追求技术而忽视实用性

### AI 时代的新思考

在 AI 时代，我们需要重新思考：
- **什么值得代码化？** 只有真正需要规模化、标准化的任务
- **什么适合提示词？** 灵活多变、创造性的任务
- **如何平衡两者？** 工具提供框架，提示词提供灵活性

## 结论与建议

1. **对于大多数个人开发者**：两个精心设计的提示词足够了
2. **对于团队和企业**：工具化方案仍有其价值
3. **最佳实践**：先用提示词验证需求，确实需要时再工具化

### 未来方向

也许最好的方案是：
- 保持核心提示词的简洁性
- 用最小化的脚本提供便利性
- 让 AI 和人类各自发挥所长

```python
# 极简方案示例
def generate_focus():
    """一个 10 行的脚本可能就够了"""
    prompt = load_prompt("focus.md")
    response = cursor_ai.complete(prompt)
    save_file("Focus.md", response)
```

## 致谢

感谢这个"灵魂拷问"，它让我们重新审视了工具开发的本质，提醒我们：

**简单，往往就是最好的答案。** 